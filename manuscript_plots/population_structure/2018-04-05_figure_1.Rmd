---
title: "code_for_figure_1"
author: "JoeColgan"
date: "5 April 2018"
output: html_document
---

For the purpose of the Colgan et al. figure 1 which is a combination of:
1) Geographical map of collection sites 
2) Principal component analysis using genome-wide unlinked SNPs
3) Principal component analysis using genome-wide linked SNPs
4) Scatterplot of number of predicted K populations from ADMIXTURE
5) Scatterplot of effective population size

```{r}
## Set working directory
#setwd("/Users/tcolgan/Documents/2015-09-03_Bter_analysis/2015-12-14_RScipts/")

## Load libraries:
libraries <- c("devtools", "ggplot2", "ggmap", "SNPRelate", 
               "reshape", "ggpubr", "Hmisc")
for (lib in libraries) {
        if (require(package = lib, character.only = TRUE)) {
                print("Successful")
        } else {
                print("Installing")
                source("https://bioconductor.org/biocLite.R")
                biocLite(pkgs = lib)
                library(lib, character.only = TRUE )
        }
}

```

1) Geographical map of collection sites  

```{r, echo=FALSE}
## Define input file to read in. Input is in csv format:
input<-"2018-05-13_input_for_ggmaps.csv"

## Read input and store in 'data' variable:
data <- read.csv(input, header=TRUE)

# Subset data based on treatment
arable_data<-subset(data, Treatment=="Arable" & Bombus_1=="terrestris")
pastoral_data<-subset(data, Treatment=="Pastoral" & Bombus_1=="terrestris")
mixed_data<-subset(data, Treatment=="Mixed" & Bombus_1=="terrestris")

# Load latitude values into a variable
pastoral_data_lat <- pastoral_data[,3]
arable_data_lat<-arable_data[,3]
mixed_data_lat<-mixed_data[,3]

## Load longitude values into a variable
pastoral_data_long <-pastoral_data[,4]
arable_data_long<-arable_data[,4]
mixed_data_long<-mixed_data[,4]

## Load longitude and latitude values into a dataframe:
pastoral_data_df <- as.data.frame(cbind(pastoral_data_long,pastoral_data_lat))
arable_data_df <- as.data.frame(cbind(arable_data_long,arable_data_lat))
mixed_data_df <- as.data.frame(cbind(mixed_data_long,mixed_data_lat))

## Get locations of data-points using toner-background maptype:
pastoral_map_data<-get_map(location = c(lon = mean(pastoral_data_df$pastoral_data_long), lat = mean(pastoral_data_df$pastoral_data_lat)), zoom = 6, maptype = 'satellite')

arable_map_data<-get_map(location = c(lon = mean(arable_data_df$arable_data_long), lat = mean(arable_data_df$arable_data_lat)), zoom = 6, maptype = 'satellite')

mixed_map_data<-get_map(location = c(lon = mean(mixed_data_df$mixed_data_long), lat = mean(mixed_data_df$mixed_data_lat)), zoom = 6, maptype = 'satellite')

map<- get_googlemap(center =c(lon = mean(pastoral_data_df$pastoral_data_long), lat = mean(pastoral_data_df$pastoral_data_lat)), zoom = 6, maptype = 'terrain', color="bw", style=c(feature="all",element="labels",visibility="off"))

## Assign landuse type to 'status' field highlighting the landuse type for differentiating when plotting:
pastoral_data_df$status <- "Pastoral"
arable_data_df$status <- "Arable"
mixed_data_df$status <- "Mixed"

pastoral_data_df$site_number <- as.character(pastoral_data$site_number_for_plots)
arable_data_df$site_number <- as.character(arable_data$site_number_for_plots)
mixed_data_df$site_number <- as.character(mixed_data$site_number_for_plots)

## Alter the column names:
colnames(pastoral_data_df) <- c("longitude", "latitude", "landuse", "site_number")
colnames(arable_data_df)   <- c("longitude", "latitude", "landuse", "site_number")
colnames(mixed_data_df)    <- c("longitude", "latitude", "landuse", "site_number")

## Combine the landuse dataframes:
combined_df<- rbind(pastoral_data_df, 
                    arable_data_df,
                    mixed_data_df)

## Generate the map:
test <- ggmap(map) +
        xlab("Longitude") +
        ylab("Latitude") +
        geom_point(data = combined_df, 
                   aes(x = longitude, 
                       y = latitude, 
                       colour=landuse,
                       fill=landuse,
                       shape=landuse), 
                       size = 10) +
        geom_text(aes(x=longitude, y=latitude, label=combined_df$site_number), data=combined_df, colour="white", size=6) +
        theme_bw() +
        theme(plot.title = element_text(size = 15, face = "bold") , legend.text=element_text(size=12)) +
        theme(legend.justification = c(1, 1), legend.position = c(0.95, 0.95))

## Adjust the plotting colours for each treatment (i.e. landuse)
## Adjust the size of the picture borders allowing for expanding the x- and y-axes.
collection_site_plot <- test + scale_colour_manual(values = c("blue", "orange", "red")) +
                                scale_x_continuous(limits = c(-6.5, 2.5), expand = c(0, 0)) +
                                scale_y_continuous(limits = c(49.5, 56.5), expand = c(0, 0)) +
                                theme(text=element_text(size=20),
                                      axis.title=element_text(size=20,face="bold"))
```

2) Principal component analysis using genome-wide unlinked SNPs

```{r}
### PCA analysis:
## Set working directory:  
#setwd("/Volumes/apocrita/autoScratch/2016-10-11_Bombus_population_genomics/results/2017-11-02_terrestris_combined_reanalysis/results/temp/09_final_clean/filtered_temp/02_sorted/2017-11-23-coverage_1/2017-11-26-sample_n41_for_nsl/")

## Assign the input name:  
input_vcf <- "freebayes_hap0_minQ_1_minaltfrac_0.25_minCov1.Bter_n41.NC_only.minQ20.snps_only.no_hets.sites_low_freq.rare_variants_free.maxMeanDP100.recode.vcf"

## Convert VCF to genome data structure (gds) file format
## gds is a container for storing annotation data and SNP genotypes.
## In this format, each byte encodes up to four SNP genotypes thereby reducing file size and access time.
## The GDS format supports data blocking so that only the subset of data that is being processed needs
## to reside in memory. GDS formatted data is also designed for efficient data access to large datasets.

## Use the name of input to designate the name for the GDS file format.
input_vcf_gds <- gsub(".vcf", ".gds", input_vcf)

## Reformat VCF into GDS format
snpgdsVCF2GDS(input_vcf, input_vcf_gds, method="biallelic.only")

## Extract genotype information:
input_vcf_gds_genofile <- snpgdsOpen(input_vcf_gds)

## Extract genotype information and generate genotypic matrix:  
input_vcf_gds_genofile_matrix <- read.gdsn(index.gdsn(input_vcf_gds_genofile, "genotype"))

## Perform PCA and store output in variable:  
pca      <- snpgdsPCA(input_vcf_gds_genofile, num.thread=2, autosome.only=FALSE)

## Calculate percentages for principal components:  
pc_percent      <- pca$varprop*100
## Print rounded up percentages:  
print(round(pc_percent, 2))

## Extract sample names from input:  
sample.id      <- read.gdsn(index.gdsn(input_vcf_gds_genofile, "sample.id"))

## Read in file containing treatment information. 
## This file should contain 'treatment information' for each sample and be in the same order as each sample. 
## i.e. the first treatment information would be assigned to the first sample, etc., etc.
#pop_code<-scan("./new_landuse_info.n41.txt", what=character())

## Read in table:
pop_code_df <- read.table(file = "landuse_site_info_n41.txt",
                          header = FALSE)

## Rename columns:
colnames(pop_code_df) <- c("sample", "site_number", "landuse")

##
pop_code <- pop_code_df$landuse

## Generate a dataframe containing a column for:
## 1) Sample name
## 2) Treatment condition
## 3) First principal component of interest
## 4) Second principal component of interest
tab <- data.frame(sample.id = pca$sample.id,
                  pop = factor(pop_code)[match(pca$sample.id, sample.id)],
                  EV1 = pca$eigenvect[,1],    # the first eigenvector
                  EV2 = pca$eigenvect[,2],    # the second eigenvector
                  stringsAsFactors = FALSE)

## Rename the samples for plotting:  
## Renaming the sample.ids
new_names <- list()

## Create a list:
for (name in sample.id){
        new_names[name] <- paste(strsplit(name, "_")[[1]][5],"_",strsplit(name, "_")[[1]][6], sep="")
}

## Unlist as a character string and update sample ids:
tab$sample.id <- as.character(unlist(new_names))

## Add another column for site_id:
tab$site_id <- pop_code_df$site_number

## Reorder:
#tab_ordered <- tab[order(tab$sample.id),]

## Update names to reflect 
#tab_ordered$site_id <- c("01", "01", "02", "02", "03","03","04","04","05","06",
  "07", "08", "08", "09", "09","10","11","12","13","14",
  "14", "15", "16", "16", "17","17","18","18","19","20",
  "20", "21", "22", "23", "24", "25","26","27","27","28","28")

## Check status of whether there are two or one individual per site:
new_site_id <- vector()

for (i in 1:length(tab$site_id)){
        status <- duplicated(tab$site_id)[i]
        if (status==FALSE){
                print("Not duplicated")
                new_site_id <- c(new_site_id, paste(tab$site_id[i], "A", sep=""))
        }
        else {
                print("Duplicated")
                new_site_id <- c(new_site_id, paste(tab$site_id[i], "B", sep=""))
        }
}

## Write samples to file:
write(new_site_id, file="sample_names.txt", sep="\t")

## Update site information: 
tab$site_id <- new_site_id

## Using the 'tab' dataframe, plot two principal components of interest using ggplot2:
#landuse_plot<- ggplot(tab, aes(x=tab$EV1, y=tab$EV2, color = tab$pop, shape=tab$pop)) +
#        geom_point(size=7) +
#        geom_text(size=5, colour="black", aes(label=tab$site_id))  +
#        xlab(paste("PC1"," ",round(pc_percent[1], 2),"%")) +
#        ylab(paste("PC2"," ",round(pc_percent[2], 2),"%")) + 
#        scale_color_manual(values= c("light blue", "orange", "pink"))  +
#        theme_minimal() +
#        theme(legend.position="none")

## Plot:
#landuse_plot <- landuse_plot +
#                theme(axis.text=element_text(size=15),
#                axis.title=element_text(size=15,face="bold"))

## Alternatively, to plot with just sample ids and not points:
names_plot<- ggplot(tab, aes(x=tab$EV1, y=tab$EV2, color = tab$pop)) +
        #geom_point(shape=16, size=4, alpha=0.4, show.legend = T) +
        theme_minimal() +
        xlab(paste("Principal component", 1," ","(",round(pc_percent[1], 2), "%", ")", sep="")) +
        ylab(paste("Principal component", 2," ","(",round(pc_percent[2], 2), "%", ")", sep="")) + 
        geom_text(size=6, position=position_jitter(width=0.04, height=0.04), aes(label=tab$site_id, color=tab$pop)) +
        scale_color_manual(values= c("blue", "orange", "red"))

## Adjust the size of the labels:
names_plot <- names_plot +
                 theme(axis.text=element_text(size=20),
                 axis.title=element_text(size=20,face="bold")) +
                 theme(legend.position="none")

## Plot:
names_plot

## Plot together:
ggarrange(collection_site_plot, 
          names_plot,
          ncol=2, nrow=1,
          labels = c("A", "B"))
```

Comparison between latitude coordinates and PC2:

```{r}
## Read in landuse information including latitude coordinates:
landuse_info <- read.table("landuse_site_info_n41.txt", header=FALSE)

tab$latitude <- landuse_info$V4

## Subset columns of interest:
tab_subset <- tab[,c(3,4,6)]

## Test for correlation between each variable:
res2 <- rcorr(as.matrix(tab_subset))

# Extract the correlation coefficients
res2$r

# Extract p-values
res2$P

lat_plot<- ggplot(tab, aes(x=tab$EV2, y=tab$latitude, color = tab$pop)) +
        geom_point(shape=16, size=4, alpha=0.4, show.legend = T) +
        theme_minimal() +
        xlab(paste("Principal component ", 2," ","(",round(pc_percent[2], 2), "%", ")", sep="")) +
        ylab("Latitude") + 
        #geom_text(size=6, position=position_jitter(width=0.04, height=0.04), aes(label=tab$site_id, color=tab$pop)) +
        geom_smooth(method=lm, na.rm = TRUE, fullrange= TRUE,
               aes(group=1),colour="grey", se=FALSE)+
        scale_color_manual(values= c("red", "orange", "blue"))

## Adjust the size of the labels:
lat_plot <- lat_plot +
                 theme(axis.text=element_text(size=15),
                 axis.title=element_text(size=15,face="bold")) +
                 theme(legend.position="none")

## Plot with site names instead of points:
lat_labs<- ggplot(tab, aes(x=tab$EV2, y=tab$latitude, color = tab$pop)) +
        #geom_point(shape=16, size=4, alpha=0.4, show.legend = T) +
        theme_minimal() +
        xlab(paste("Principal component ", 2," ","(",round(pc_percent[2], 2), "%", ")", sep="")) +
        ylab("Latitude") + 
        #geom_text(size=4, position=position_jitter(width=0.04, height=0.04), aes(label=tab$site_id, color=tab$pop)) +
        geom_text(size=4, aes(label=tabS$site_id, color=tab$pop)) +
        geom_smooth(method=lm, na.rm = TRUE, fullrange= TRUE,
               aes(group=1),colour="grey", se=FALSE)+
        scale_color_manual(values= c("red", "orange", "blue"))

## Adjust the size of the labels:
lat_labs <- lat_labs +
                 theme(axis.text=element_text(size=15),
                 axis.title=element_text(size=15,face="bold")) +
                 theme(legend.position="none")

## Print to console:
ggarrange(lat_plot, lat_labs,
          nrow = 2,
          ncol = 1,
          align = "v")

```

```{r}
## Plot PCA of larger number of samples (n=46):
## Assign the input name:  
input_n46_vcf <- "n46_samples/freebayes_hap0_minQ_1_minaltfrac_0.25_minCov1.Bter_n46.NC_only.minQ20.snps_only.no_hets.sites_low_freq.maxmissing1.0.rare_variants_removed.recode.vcf"

## Convert VCF to genome data structure (gds) file format
## gds is a container for storing annotation data and SNP genotypes.
## In this format, each byte encodes up to four SNP genotypes thereby reducing file size and access time.
## The GDS format supports data blocking so that only the subset of data that is being processed needs
## to reside in memory. GDS formatted data is also designed for efficient data access to large datasets.

## Use the name of input to designate the name for the GDS file format.
input_n46_vcf_gds <- gsub(".vcf", ".gds", input_n46_vcf)

## Reformat VCF into GDS format
snpgdsVCF2GDS(input_n46_vcf, input_n46_vcf_gds, method="biallelic.only")

## Extract genotype information:
input_n46_vcf_gds_genofile <- snpgdsOpen(input_n46_vcf_gds)

## Extract genotype information and generate genotypic matrix:  
input_n46_vcf_gds_genofile_matrix <- read.gdsn(index.gdsn(input_n46_vcf_gds_genofile, "genotype"))

## Perform PCA and store output in variable:  
pca_n46      <- snpgdsPCA(input_n46_vcf_gds_genofile, num.thread=2, autosome.only=FALSE)

## Calculate percentages for principal components:  
pc_percent_n46      <- pca_n46$varprop*100
## Print rounded up percentages:  
print(round(pc_percent_n46, 2))

## Extract sample names from input:  
sample_id_n46     <- read.gdsn(index.gdsn(input_n46_vcf_gds_genofile, "sample.id"))

## Read in file containing treatment information. 
## This file should contain 'treatment information' for each sample and be in the same order as each sample. 
## i.e. the first treatment information would be assigned to the first sample, etc., etc.
## Read in table:
pop_code_n46_df <- read.table(file = "n46_samples/landuse_site_info_n46.txt",
                          header = FALSE)

## Rename columns:
colnames(pop_code_n46_df) <- c("sample", "site_number", "landuse")

##
pop_code_n46 <- pop_code_n46_df$landuse

## Generate a dataframe containing a column for:
## 1) Sample name
## 2) Treatment condition
## 3) First principal component of interest
## 4) Second principal component of interest
tab_n46 <- data.frame(sample.id = pca_n46$sample.id,
                  pop = factor(pop_code_n46)[match(pca_n46$sample.id, sample_id_n46)],
                  EV1 = pca_n46$eigenvect[,1],    # the first eigenvector
                  EV2 = pca_n46$eigenvect[,2],    # the second eigenvector
                  stringsAsFactors = FALSE)

## Rename the samples for plotting:  
## Renaming the sample.ids
new_names <- list()

## Create a list:
for (name in sample_id_n46){
        new_names[name] <- paste(strsplit(name, "_")[[1]][5],"_",strsplit(name, "_")[[1]][6], sep="")
}

## Unlist as a character string and update sample ids:
tab_n46$sample.id <- as.character(unlist(new_names))

## Add another column for site_id:
tab_n46$site_id <- pop_code_n46_df$site_number

## Check status of whether there are two or one individual per site:
new_site_id <- vector()

for (i in 1:length(tab_n46$site_id)){
        status <- duplicated(tab_n46$site_id)[i]
        if (status==FALSE){
                print("Not duplicated")
                new_site_id <- c(new_site_id, paste(tab_n46$site_id[i], "A", sep=""))
        }
        else {
                print("Duplicated")
                new_site_id <- c(new_site_id, paste(tab_n46$site_id[i], "B", sep=""))
        }
}

## Write samples to file:
#write(new_site_id, file="sample_names.txt", sep="\t")

## Update site information: 
tab_n46$site_id <- new_site_id

## Alternatively, to plot with just sample ids and not points:
names_n46_plot<- ggplot(tab_n46, aes(x=tab_n46$EV1, y=tab_n46$EV2, color = tab_n46$pop)) +
        #geom_point(shape=16, size=4, alpha=0.4, show.legend = T) +
        theme_minimal() +
        xlab(paste("Principal component", 1," ","(",round(pc_percent_n46[1], 2), "%", ")", sep="")) +
        ylab(paste("Principal component", 2," ","(",round(pc_percent_n46[2], 2), "%", ")", sep="")) + 
        geom_text(size=6, position=position_jitter(width=0.04, height=0.04), aes(label=tab_n46$site_id, color=tab_n46$pop)) +
        scale_color_manual(values= c("blue", "orange", "red"))

## Adjust the size of the labels:
names_n46_plot <- names_n46_plot +
                 theme(axis.text=element_text(size=20),
                 axis.title=element_text(size=20,face="bold")) +
                 theme(legend.position="none")

## Plot:
names_n46_plot

## Plot together:
ggarrange(names_n46_plot, 
          names_plot,
          ncol=2, nrow=1,
          labels = c("A", "B"))

```

3) Scatterplot of PCA using output from fineSTRUCTURE:

```{r}
## Set working directory:
setwd("/Volumes/apocrita/autoScratch/2016-10-11_Bombus_population_genomics/results/2017-11-02_terrestris_combined_reanalysis/results/2017-11-19_run_ldhelmet/2018-04-05_new_effective_population_size/")

## Read in output from fineSTRUCTURE (namely the combined_analysis_linked.chunkcounts.out file):
finestructure_input <- "./combined_analysis_linked.chunkcounts.out"

##### READ IN THE CHUNKCOUNT FILE
dataraw<-as.matrix(read.table(finestructure_input,row.names=1,header=T,skip=1)) # read in the pairwise coincidence

## Convert matrix to dataframe:
dataraw_df <- as.data.frame(dataraw)

## Change of sample names:
new_names <- list()

## Create a list:
for (name in colnames(dataraw)){
        new_names[name] <- paste(strsplit(name, "_")[[1]][4],"_",strsplit(name, "_")[[1]][5], sep="")
}

## Add the sample names to dataframe:
dataraw_df$samples <- as.character(unlist(new_names))

## Add information relating to treatment (i.e. land use):  
dataraw_df$landuse <- pop_code

## Perform principal componant and plot:
finestructure_plot<- autoplot(prcomp(dataraw_df[,1:41]), 
                            data = dataraw_df, 
                            colour = 'landuse', 
                            label=F, shape=F, 
                            label.size=6, 
                            frame=F, 
                            frame.type='norm') +
                            geom_text(size=4, 
                            position=position_jitter(width=0.01, height=0.01),
                            aes(label=dataraw_df$samples,
                            color=dataraw_df$landuse)) +
                            scale_color_manual(values=c("blue", "orange", "red")) +
                            labs(colour = "Landuse type", size=10) +
                            theme_minimal() 
        

## Make axes larger:
finestructure_plot <- finestructure_plot + 
                        theme(axis.text=element_text(size=12),
                        axis.title=element_text(size=12,face="bold")) +
                        theme(legend.position="none")

## Print plot to console:
finestructure_plot
```


4) Scatterplot of number of predicted K populations from ADMIXTURE

```{r}
## Scatterplot for output of admixture:
setwd("/Volumes/apocrita/autoScratch/2016-10-11_Bombus_population_genomics/results/2017-11-02_terrestris_combined_reanalysis/results/temp/09_final_clean/filtered_temp/02_sorted/2017-11-23-coverage_1/2017-11-28-admixture")

## Read in data for plotting of scatterplot:
admixture_data <- read.table("./combined_CV.counts.txt", header=F)

## Subset column 3 and 4 containing information on proposed number of populations and CV error value:
admixture_data_subset <- admixture_data[,3:4]

## Reformat the third column:
admixture_data_subset$V3<- gsub('\\(K=', '', admixture_data_subset$V3)

admixture_data_subset$V3<- gsub('\\):', '', admixture_data_subset$V3)

## Rename columns and sort by K populations numerically:
admixture_data_subset_sorted<- admixture_data_subset[order(as.numeric(as.character(admixture_data_subset$V3))),]

## Rename columns:
colnames(admixture_data_subset_sorted) <- c("k", "cross_validation_error")

## Reorder levels:
admixture_data_subset_sorted$k<- factor(admixture_data_subset_sorted$k, levels = admixture_data_subset_sorted$k)

admixture_data_subset_sorted$cross_validation_error <- as.numeric(admixture_data_subset_sorted$cross_validation_error)

## Plot using ggplot:
admixture_scatterplot <- ggplot(admixture_data_subset_sorted, 
                                aes(x=admixture_data_subset_sorted$k,
                                    y=admixture_data_subset_sorted$cross_validation_error)) +
                                xlab(expression(italic("K"))) +
                                ylab("Cross validation error") +
                                geom_point(size=3) +
                                theme_minimal()

## Make axes text font bigger:
admixture_scatterplot <- admixture_scatterplot +
                         theme(axis.text=element_text(size=12),
                         axis.title=element_text(size=12,face="bold"))

## Print to console:
admixture_scatterplot

```

5) Combined plot:

```{r}
## Plot a combined graph:
ggarrange(collection_site_plot,
          names_plot,
          finestructure_plot,
          admixture_scatterplot,
          ncol=2, nrow=2,
          labels=c("A", "B", "C", "D"))
```
